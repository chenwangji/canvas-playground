(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{59:function(t,a,s){"use strict";s.r(a);var e=s(0),n=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h3",{attrs:{id:"阴影"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阴影","aria-hidden":"true"}},[t._v("#")]),t._v(" 阴影")]),s("p",[t._v("阴影相关有以下4个属性：")]),s("ul",[s("li",[s("code",[t._v("context.shadowColor")]),t._v(": 阴影颜色。")]),s("li",[s("code",[t._v("context.shadowOffsetX")]),t._v(": 阴影水平位移。正值向右，负值向左。")]),s("li",[s("code",[t._v("context.shadowOffsetY")]),t._v(": 阴影垂直位移。正值向下，负值向上。")]),s("li",[s("code",[t._v("context.shadowBlur")]),t._v(": 阴影模糊半径。")])]),s("p",[t._v("需要注意的是，这里的阴影同其他属性设置一样，都是基于状态的设置。因此，如果只想为某一个对象应用阴影而不是全局阴影，需要在下次绘制前重置阴影的这四个属性。")]),s("p",[t._v("例如，创建一个向右下方位移各5px的红色阴影，模糊2px，可以这样写。")]),s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("context"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shadowColor "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token string"}},[t._v('"red"')]),t._v("\ncontext"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shadowOffsetX "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("5")]),t._v("\ncontext"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shadowOffsetY "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("5")]),t._v("\ncontext"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shadowBlur"),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("2")]),t._v("\n")])]),s("h3",{attrs:{id:"透明度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#透明度","aria-hidden":"true"}},[t._v("#")]),t._v(" 透明度")]),s("p",[s("code",[t._v("context.globalAlpha")]),t._v("\n全局透明度属性，默认值为 1.0，取值范围是 0 ~ 1.0。同样是基于状态。")]),s("h3",{attrs:{id:"图像合成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图像合成","aria-hidden":"true"}},[t._v("#")]),t._v(" 图像合成")]),s("p",[s("code",[t._v("context.globalCompositeOperation")])]),s("p",[t._v("两个图像重合的时候，就涉及到了对这两个图像的合成处理。"),s("code",[t._v("globalCompositeOperation")]),t._v(" 属性或返回如何将一个源（新的）图像会知道目标（已有）的图像上。")]),s("p",[s("strong",[t._v("源图像 = 打算放置到画布上的绘图")])]),s("p",[s("strong",[t._v("目标图像 = 已经放置到画布上的绘图")])]),s("p",[t._v("具体属性值及其含义参考：")]),s("ol",[s("li",[s("a",{attrs:{href:"http://airing.coding.me/canvas/14682038620119.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Canvas教程(19)——全局阴影与图像合成")])]),s("li",[s("a",{attrs:{href:"https://blog.csdn.net/laijieyao/article/details/41862473",target:"_blank",rel:"noopener noreferrer"}},[t._v("【HTML5】Canvas之globalCompositeOperation属性详解")])])])])}],!1,null,null,null);a.default=n.exports}}]);